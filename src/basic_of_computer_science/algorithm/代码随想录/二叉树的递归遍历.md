---
title: äºŒå‰æ ‘çš„éå†
category:
  - Algorithm
---

# äºŒå‰æ ‘çš„éå†



## å‚è€ƒé“¾æ¥

[äºŒå‰æ ‘çš„é€’å½’éå† - ä»£ç éšæƒ³å½•](https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html#%E6%80%9D%E8%B7%AF)

[äºŒå‰æ ‘çš„è¿­ä»£éå† - ä»£ç éšæƒ³å½•](https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E6%80%9D%E8%B7%AF)

[145. äºŒå‰æ ‘çš„ååºéå† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

[94. äºŒå‰æ ‘çš„ä¸­åºéå† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)



## ä¸­åºéå†



### è¿­ä»£éå†ï¼ˆç»Ÿä¸€è¿­ä»£ï¼‰

[äºŒå‰æ ‘çš„ç»Ÿä¸€è¿­ä»£æ³• - ä»£ç éšæƒ³å½•](https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC)

æ„Ÿè°¢ Carl å“¥ æä¾›çš„ä¸­åºéå†ç»Ÿä¸€è¿­ä»£æ³•

æ„Ÿè§‰ Carl å“¥ æä¾›çš„ä¸­åºéå†ç»Ÿä¸€è¿­ä»£æ³•ï¼ˆä¸ æ™®é€šçš„ä¸­åºéå†è¿­ä»£æ³•ç›¸æ¯”ï¼Œ[äºŒå‰æ ‘çš„è¿­ä»£éå† - ä»£ç éšæƒ³å½•](https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)ï¼‰

è·Ÿ äºŒå‰æ ‘çš„å…ˆåºéå†ï¼ˆè¿­ä»£éå†ï¼Œ[äºŒå‰æ ‘çš„è¿­ä»£éå† - ä»£ç éšæƒ³å½•](https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)ï¼‰è¾ƒä¸ºä¸€è‡´ï¼Œæ‰€ä»¥ç‰¹åœ°å†å»å­¦äº†ä¸€é

çœ‹å®Œ Carl å“¥çš„é¢˜è§£ ä»¥åŠ å½•å‹æä¾›çš„ Java é¢˜è§£ï¼Œè‡ªå·±å†™äº†ä¸€é

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<Integer>();

        Deque<TreeNode> stack = new LinkedList<>();
        List<Integer> res = new ArrayList<>();
        stack.offerLast(root);
        while (!stack.isEmpty()) {
            //ä¸­åºéå†ï¼Œè®¿é—®é¡ºåº ä¸ å¤„ç†é¡ºåº ä¸åŒï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
            if (stack.peekLast() != null) {
                TreeNode tmp = stack.pollLast();

                if (tmp.right != null) stack.offerLast(tmp.right);
                //ä¸­é—´èŠ‚ç‚¹ï¼Œnull ä¸ºè®¿é—®æ ‡è®°
                stack.offerLast(tmp);
                stack.offerLast(null);

                if (tmp.left != null) stack.offerLast(tmp.left);
            } else {    //è¯¥èŠ‚ç‚¹å·²ç»è®¿é—®è¿‡äº†
                //å¼¹ç©ºèŠ‚ç‚¹
                stack.pollLast();
                res.add(stack.pollLast().val);
            }
        }
        return res;
    }
}
```

æƒ³ä¸åˆ° LinkedList / Stack è¿˜èƒ½å­˜ç©ºèŠ‚ç‚¹ï¼ŒçœŸä¸é”™ï¼Œé•¿è§è¯†äº†

ï¼ˆä¸è¿‡ï¼Œä¸çŸ¥é“è¿™ä¼šä¸ä¼šæˆä¸ºä¸€ä¸ªåˆ¶é€ æ½œåœ¨ bug çš„åœ°æ–¹ï¼Œæ¯”å¦‚å¤„ç†ç©ºèŠ‚ç‚¹ğŸ˜‚ï¼Ÿåˆšå¼€å§‹å°±æŠŠ `stack.peekLast() != null` å†™æˆäº† `stack != null`ï¼Œç„¶åå°±åˆ¤æ–­ç©ºèŠ‚ç‚¹çš„å³å­©å­æ˜¯å¦ä¸ºç©ºäº†... ï¼‰





## ååºéå†



### é€’å½’éå†

ä¸ªäººå°è¯•ï¼ˆâŒï¼‰

æŠŠ é€’å½’ è·Ÿè¿­ä»£éå†ææ··äº†ï¼Œçå†™

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    Deque<Integer> stack = new ArrayDeque<>();
    List<Integer> res = new ArrayList<>();

    public List<Integer> postorderTraversal(TreeNode root) {
        if (root == null) return null;
        
        stack.offerLast(root);
        while (stack != null) {
            TreeNode tmp = stack.peek();
            
            postorderTraversal(stack.peek());
        }
    }
    public void postorder(TreeNode root) {
        if (root == null) return;

        while (stack != null) {
            TreeNode tmp = stack.peek();
            if (tmp.right != null) stack.offerLast(tmp.right);
            if (tmp.left != null) stack.offerLast(tmp.left);
            postorder(stack.peek());
            res.add(stack.pollLast());
        }
    }
}
```

éšåï¼Œçœ‹äº†ä¸‹ Carl å“¥çš„è®²è§£ï¼Œè‡ªå·±å†å†™äº†ä¸€é

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        
        List<Integer> list = new ArrayList<>();
        postorder(root, list);
        return list;
    }

    public void postorder(TreeNode root, List<Integer> list) {
        if (root == null) return;
        postorder(root.left, list);
        postorder(root.right, list);
        list.add(root.val);
    }
}
```



### è¿­ä»£éå†

çœ‹äº†é¢˜è§£åï¼Œè‡ªå·±å†™äº†ä¸€é

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<>(); 
        stack.offerLast(root);
        while (!stack.isEmpty()) {
            TreeNode tmp = stack.pollLast();
            res.add(tmp.val);
            if (tmp.left != null) stack.offerLast(tmp.left);
            if (tmp.right != null) stack.offerLast(tmp.right);
        }
        // è¿™é‡Œå¯ä»¥ä½¿ç”¨ Collections.reverse(res); åšé¢˜æ—¶ä¸çŸ¥é“æœ‰è¿™ç§ç”¨æ³•ï¼Œçœ‹äº†å½•å‹çš„é¢˜è§£æ‰å‘ç°å¯ä»¥è¿™æ · 
        for (int i = 0, j = res.size() - 1; i < j; i++, j--) {
            Integer tmp = res.get(i);
            res.set(i, res.get(j));
            res.set(j, tmp);
        }
        
        return res;
    }
}
```



### ä¼˜ç§€é¢˜è§£

[äºŒå‰æ ‘çš„é€’å½’éå† - ä»£ç éšæƒ³å½•](https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html#%E6%80%9D%E8%B7%AF)

[äºŒå‰æ ‘çš„è¿­ä»£éå† - ä»£ç éšæƒ³å½•](https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E6%80%9D%E8%B7%AF)

